#!/usr/bin/env python3
# -*- coding:utf-8 -*-
"""
For lightcurves generated from synthetic data
"""

from datetime import datetime
from typing import TYPE_CHECKING, Dict

import numpy as np
from astropy.time import Time, TimeDelta
from astropy.timeseries import TimeSeries
from astropy.units import Quantity, Unit
from mind_the_gaps.simulator import Simulator
from numpy import floating
from numpy.typing import NDArray
from sqlalchemy import DateTime, Float, ForeignKey, Sequence, String
from sqlalchemy.orm import Mapped, mapped_column, relationship

from voidorchestra.db.lightcurve import Lightcurve

if TYPE_CHECKING:
    from voidorchestra.db import QPOModel


class LightcurveSynthetic(Lightcurve):
    """
    Synthetic lightcurve with any cadence.

    Attributes
    ----------
    rate_mean_value: float
        Mean rate of simulated observations, unit is 'per second'.
    rate_mean_units: str
        The units of the mean rate.
    qpo_model_id: int
        The ID of the QPO model this lightcurve uses.
    qpo_model: relationship
        The QPO model used to generate the synthetic lightcurve.
    random_state: int
        The random seed for the simulation.
    """

    rate_mean_value: Mapped[float] = mapped_column(Float(), nullable=True)
    rate_mean_units: Mapped[str] = mapped_column(String(32), nullable=True)
    exposure_value: Mapped[int] = mapped_column(Float(), nullable=True)
    exposure_units: Mapped[str] = mapped_column(String(32), nullable=True, use_existing_column=True)
    qpo_model_id: Mapped[int] = mapped_column(ForeignKey("qpo_model.id"), nullable=True)
    qpo_model: Mapped["QPOModel"] = relationship(
        "QPOModel",
        back_populates="lightcurves",
    )
    random_state: Mapped[int] = mapped_column(
        Sequence("unique_random_state", start=1, increment=1),
        nullable=True,
    )

    __mapper_args__: Dict[str, str] = {
        "polymorphic_identity": "lightcurve_synthetic",
    }

    def get_rate_mean(self) -> Quantity:
        """
        Gets the mean rate with units.

        Returns
        -------
        Quantity:
            The mean rate, in counts per second.
        """
        return Quantity(self.rate_mean_value, unit=self.rate_mean_units)

    def __repr__(self) -> str:
        """
        Gets the name of the lightcurve.

        Returns
        -------
        str:
            The string representation of the lightcurve.
        """
        raise NotImplementedError("This is an abstract class.")


class LightcurveSyntheticRegular(LightcurveSynthetic):
    """
    Synthetic lightcurve with regular cadence.

    Attributes
    ----------
    observation_start: datetime
        First date of the campaign.
    observation_count: int
        Number of simulated observations.
    cadence_value: float
        :ength of time between each observation.
    cadence_units: str
        Units of the cadence, in Astropy-parseable format (e.g. 'd', 'days').
    exposure_value: float
        Length of exposure for each simulated observation.
    exposure_units: str
        Units of the exposure time, in Astropy-parseable format (e.g. 's', 'seconds').
    """

    __mapper_args__: Dict[str, str] = {
        "polymorphic_identity": "lightcurve_synthetic_regular",
    }

    observation_start: Mapped[datetime] = mapped_column(DateTime(), nullable=True, use_existing_column=True)
    observation_count: Mapped[int] = mapped_column(nullable=True)
    cadence_value: Mapped[float] = mapped_column(Float(), nullable=True)
    cadence_format: Mapped[str] = mapped_column(String(32), nullable=True)
    exposure_value: Mapped[str] = mapped_column(Float(), nullable=True, use_existing_column=True)
    exposure_units: Mapped[str] = mapped_column(String(32), nullable=True, use_existing_column=True)

    EXTENSION_FACTOR: int = 2  # How long beyond the actual 'observed' campaign to simulate the LC

    def __repr__(self) -> str:
        """
        Gets the name of the lightcurve.
        """
        return f"LightcurveSyntheticRegular(id={self.id!r}, name={self.name!r})"

    def get_exposure(self) -> Quantity:
        """
        Gets the exposure duration for this lightcurve, with units.

        Returns
        -------
        Quantity:
            The exposure duration for these synthetic observations.
        """
        return Quantity(self.exposure_value, unit=self.exposure_units)

    def get_cadence(self) -> TimeDelta:
        """
        Gets the cadence for these observations, as an Astropy TimeDelta.

        Returns
        -------
        TimeDelta:
            The cadence for the synthetic observating campaign.
        """
        return TimeDelta(self.cadence_value, format=self.cadence_format)

    def get_data(self) -> TimeSeries:
        """
        Gets a lightcurve generated by the simulator for this method.

        Returns
        -------
        timeseries: TimeSeries
            The lightcurve generated.
        """
        rate_units: Unit = Unit(self.rate_mean_units)

        time_start_seconds: Time = Time(self.observation_start)
        time_start_seconds.format = "unix"

        time_delta_seconds: TimeDelta = self.get_cadence()
        time_delta_seconds.format = "sec"

        exposure_seconds: Quantity = self.get_exposure().to("s").value

        timeseries: TimeSeries = TimeSeries(
            time_start=time_start_seconds,
            time_delta=time_delta_seconds,
            n_samples=self.observation_count,
            data={
                "rate": np.ones(self.observation_count) * self.get_rate_mean(),
                "error": np.zeros(self.observation_count) * rate_units,
            },
        )

        simulator: Simulator = Simulator(
            self.qpo_model.get_model_for_mean_rate(self.get_rate_mean()),
            times=timeseries["time"].value,
            exposures=exposure_seconds,
            mean=self.get_rate_mean().value,
            pdf="Gaussian",
            extension_factor=self.EXTENSION_FACTOR,
            random_state=self.random_state,
        )
        rates_clean: NDArray[floating] = simulator.generate_lightcurve()
        rates_noisy, uncertainties = simulator.add_noise(rates_clean)

        timeseries["rate"] = (rates_noisy * rate_units,)
        timeseries["error"] = (uncertainties * rate_units,)
        timeseries["rate_clean"] = rates_clean
        return timeseries
