#!/usr/bin/env python3
# -*- coding:utf-8 -*-
"""
For lightcurves generated from synthetic data
"""
from pathlib import Path
from typing import Dict, List

import numpy as np
from astropy.time import TimeDelta
from astropy.timeseries import TimeSeries
from astropy.units import Quantity, Unit
from mind_the_gaps.simulator import Simulator
from numpy import floating
from numpy.typing import NDArray
from pandas import DataFrame, read_csv
from sqlalchemy import Column, DateTime, Float, ForeignKey, Integer, Sequence, String
from sqlalchemy.orm import Session, relationship

from voidorchestra import config_paths
from voidorchestra.db.lightcurve import Lightcurve


class LightcurveSynthetic(Lightcurve):
    """
    Synthetic lightcurve with any cadence.

    Attributes
    ----------
    rate_mean_value: float
        Mean rate of simulated observations, unit is 'per second'.
    rate_mean_units: str
        The units of the mean rate.
    qpo_model_id: int
        The ID of the QPO model this lightcurve uses.
    qpo_model: relationship
        The QPO model used to generate the synthetic lightcurve.
    random_state: int
        The random seed for the simulation.
    """
    rate_mean_value = Column("rate_mean_value", Float(), nullable=False)
    rate_mean_units = Column("rate_mean_units", String(32), nullable=False)
    qpo_model_id = Column(
        "qpo_model_id", Integer(),
        ForeignKey("qpo_model.id")
    )
    qpo_model = relationship(
        "QPOModel",
        back_populates="lightcurves",
    )
    random_state = Column(
        "random_state", Integer(),
        Sequence('unique_random_state', start=1, increment=1),
    )
    COLUMNS: List[str] = [ 'rate_mean', 'qpo_model_id' ]

    __mapper_args__: Dict[str, str] = {
        'polymorphic_identity': 'lightcurve_synthetic',
    }

    def get_rate_mean(self) -> Quantity:
        """

        Returns
        -------
        Quantity:
            The mean rate, in counts per second.
        """
        return Quantity(self.rate_mean_value, unit=self.rate_mean_units)

    def __repr__(self) -> str:
        """
        Gets the name of the lightcurve.

        Returns
        -------
        str:
            The string representation of the lightcurve.
        """
        raise NotImplementedError("This is an abstract class.")


class LightcurveSyntheticRegular(LightcurveSynthetic):
    """
    Synthetic lightcurve with regular cadence.

    Attributes
    ----------
    start_time: datetime
        First date of the campaign.
    observation_count: int
        Number of observations.
    cadence: float
        Gap between observations, in days.
    qpo_model: relationship
        The QPO model used to generate the synthetic lightcurve.
    """
    __mapper_args__: Dict[str, str] = {
        'polymorphic_identity': 'lightcurve_synthetic_regular',
    }

    start_time = Column("start_time", DateTime(), nullable=False)
    observation_count = Column("observation_count", Integer(), nullable=False)
    cadence_value = Column("cadence_value", Float(), nullable=False)
    cadence_format = Column("cadence_format", String(32))

    EXTENSION_FACTOR: int = 2
    COLUMNS: List[str] = [
        'start_time', 'observation_count', 'cadence',
    ]

    def __repr__(self) -> str:
        """
        Gets the name of the lightcurve.
        """
        return f"LightcurveSyntheticRegular(id={self.id!r}, name={self.name!r})"

    def get_cadence(self) -> TimeDelta:
        """
        Gets the cadence for these observations, as an Astropy TimeDelta
        """
        return TimeDelta(self.cadence_value, format=self.cadence_format)

    def get_data(self) -> TimeSeries:
        """
        Gets a lightcurve generated by the simulator for this method.

        Returns
        -------
        TimeSeries:
            The lightcurve generated.
        """
        rate_units: Unit = Unit(self.rate_mean_units)

        lightcurve: TimeSeries = TimeSeries(
            time_start=self.start_time,
            time_delta=self.get_cadence(),
            n_samples=self.observation_count,
            data={
                "rate": np.ones(self.observation_count) * rate_units,
                "error": np.zeros(self.observation_count) * rate_units,
            },
        )
        simulator: Simulator = Simulator(
            self.qpo_model.get_model_for_mean_rate(self.get_rate_mean()),
            lightcurve["time"].mjd,
            lightcurve["rate"].value,
            mean=self.get_rate_mean().value,
            pdf="Gaussian",
            extension_factor=self.EXTENSION_FACTOR,
            random_state=self.random_state,
        )
        rates_clean: NDArray[floating] = simulator.generate_lightcurve()
        rates_noisy, uncertainties = simulator.add_noise(rates_clean)
        lightcurve["rate"] = (rates_noisy * rate_units,)
        lightcurve["error"] = (uncertainties * rate_units,)
        return lightcurve

    @staticmethod
    def load_fixtures(
            session: Session,
            fixtures_path: Path = None
    ) -> None:
        """
        Loads the fixtures from disk (if they aren't loaded already)

        Parameters
        ----------
        session: Session
            A database session to add the fixtures to
        fixtures_path: Path
            The fixtures JSON file to load the fixtures from

        Raises
        ------
        FileNotFoundError
            If the passed path (or the path in the config file) does not exist
        ValueError
            If the file doesn't have the right columns.
        """
        if not fixtures_path:
            fixtures_path = Path(config_paths["lightcurve_synthetic_regular"])
            if not fixtures_path.exists():
                raise FileNotFoundError(f"The fixtures file '{fixtures_path}' does not exist.")

        fixtures_df: DataFrame = read_csv(fixtures_path, skipinitialspace=True)
        expected_columns: List[str] = Lightcurve.COLUMNS + LightcurveSynthetic.COLUMNS + LightcurveSyntheticRegular.COLUMNS
        if fixtures_df.columns != expected_columns:
            raise ValueError(
                f"Expecting columns '{", ".join(expected_columns)}'.\n Got '{", ".join(fixtures_df.columns)}'.\n"
                f"Difference: {set(expected_columns).difference(set(fixtures_df.columns))}."
            )

        for idx, row in fixtures_df.iterrows():
            session.add(
                LightcurveSyntheticRegular(
                    **row
                )
            )

        session.commit()
