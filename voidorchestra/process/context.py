from math import ceil
from pathlib import Path
from random import sample
from typing import List, Optional

from PIL import Image as PILImage
from PIL.Image import Image as PILImageClass
from PIL.ImageDraw import Draw
from sqlalchemy.orm import Session

import voidorchestra.db
from voidorchestra.db.stamp import Stamp
from voidorchestra.db.image import Image
from molegazer import config
from molegazer.log import get_logger
from molegazer.util.pil import draw_frame_and_circle


logger = get_logger(__name__.replace(".", "-"))


# This is just for fixed size mole stamps
# fixed_mole = rgb[(newyM):(newyP), (newxM):(newxP)]
#

# iterate over x for "source within catalogue"
# The dataframe content associated with x appears to be at (x - len(columns) - 1)
#   How is this not <0 for x=0???
# For each:
# xPos, yPos are the source positions on the full image
# xSize, ySize are the lengths of a square with equal area to the isoarea, plus 30 pixels
# xPosM, xPosP (and y equivs) are the lower and upper bounds of a frame around the mole
# newxM, newxP (and equivs) are the same for a fixed-size frame 50px across
# If moles are near the edge of the frame, it shifts the window to include them
#  I don't think we want this

# mole is a window on the full image RGB array using xPosM sizing
# bgr is the rgb background generated by SExtractor for that frame
# rgb_bgr [...?] is the detector counts for that window?
#   With an artificial boost to the red channel at the edges?

# mole0/bgr0 etc. are the extracted r, g and b channels as 0, 1, 2
#  I think?

# mole0 = mole[:, :, 0].flatten()
# mole1 = mole[:, :, 1].flatten()
# mole2 = mole[:, :, 2].flatten()
#
# mole_bgr0 = mole_bgr[:, :, 0].flatten()
# mole_bgr1 = mole_bgr[:, :, 1].flatten()
# mole_bgr2 = mole_bgr[:, :, 2].flatten()

# It then throws away the mole if its stamp contains any 'edges'
# Which I think (?) are the edges of the *person*, or possibly the non-person bits
# It then flattens them into 1-d arrays

# if np.any(mole_bgr0 > 2000):
#     continue
#
# background0 = bgr[:, :, 0].flatten()
# background1 = bgr[:, :, 1].flatten()
# background2 = bgr[:, :, 2].flatten()
#
# bins1 = np.arange(0, 256, 1)

# It then creates an array containing only those elements of each channel
# that are not present in the background image (really?)

# ammole0 = [i for i in mole0 if i not in background0]
# ammole1 = [i for i in mole1 if i not in background1]
# ammole2 = [i for i in mole2 if i not in background2]

# It then tries to make a 'small' stamp for the mole, from the larger frame
# It creates mini-frames of 10x10 around the 'centre' of the mole
# One labelled mole_centre, one labelled background_centre
# And reshapes them into a list of pixels (no xy info, just colour)

# smallSize = 5
# smallframey, smallframex = mole[:, :, 0].shape
# centre = int(smallframex / 2)
#
# mole_centre = mole[(centre - smallSize):(centre + smallSize), (centre - smallSize):(centre + smallSize)]
# background_centre = bgr[(centre - smallSize):(centre + smallSize), (centre - smallSize):(centre + smallSize)]
#
# pixels = np.float32(mole_centre.reshape(-1, 3))

# For each, it then runs KMeans, and attempts to cluster the pixels into two colour sets
# Counts the number of pixels with each colour group label
# and determines the 'dominant' colour in each

# n_colors = 2
# criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 200, .1)
# flags = cv2.KMEANS_RANDOM_CENTERS
# _, labels, palette = cv2.kmeans(pixels, n_colors, None, criteria, 10, flags)
# _, counts = np.unique(labels, return_counts=True)
# dominant1 = palette[np.argmax(counts)]
#
# pixels = np.float32(background_centre.reshape(-1, 3))
# n_colors = 2
# criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 200, .1)
# flags = cv2.KMEANS_RANDOM_CENTERS
# _, labels, palette = cv2.kmeans(pixels, n_colors, None, criteria, 10, flags)
# _, counts = np.unique(labels, return_counts=True)
# dominant2 = palette[np.argmax(counts)]

# It then converts the colours to 'HSP' via a weighting algorithm
# and rounds them to 2 DP
# Then calculates the difference between the background HSP and the foreground HS{
# If this is > a hardcoded value (THIS IS HELLA RACIST), then it is a mole
# If it's not, it isn't


# def isLightOrDark(rgbColor=[0, 128, 255]):
#     [r, g, b] = rgbColor
#     hsp = math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b))
#     return hsp
#
#
# hsp1 = round(isLightOrDark(dominant1), 2)
# hsp2 = round(isLightOrDark(dominant2), 2)
# difference = round(hsp2 - hsp1, 2)
#
# if difference > darkness_diff:
#     if np.any(mole_bgr0 > 2000):
#         identity = "Nothing"
#         # print ("Edge", xPos, yPos, hsp1, hsp2, difference)
#     else:
#         identity = "Mole"
#         mole_list.append([xPos, yPos, xSize])
#         # print (identity, xPos, yPos, hsp1, hsp2, difference)
# else:
#     identity = "Nothing"
#     # print (identity, xPos, yPos, hsp1, hsp2, difference)


def generate_stamps_context(
        session: Session, stamps: List[Stamp], substitute: Optional[str] = None
):
    """
    Given a list of stamps, creates 'context stamps' containing a random selection of
    moles from the patient underneath them.

    This is slightly more complicated than you might expect (!), as we need the mole
    images of interest to be scaled by an *integer* multiple, in order to avoid losing
    data during the scaling process by smearing. This means that to achieve a consistent
    'apparent' border width, hint circle radius etc. we need to have an integer scaling
    factor, and we also need to scale the context images.

    This would be simpler if we applied the border, hint circle and resizing during the
    initial stamp creation process, but adding the circle in particular causes artifacting
    in small images - you'll notice this in the context images potentially.

    Parameters
    ----------
    session: Session
        The current database session.
    stamps: List[Stamp]
        The list of stamps to generate
    substitute: Optional[str]
        An optional 'alternate' image to use
    """
    context_ratio: int = int(config['STAMPS']['context_stamps'])
    border_ratio: int = int(config['STAMPS']['border_ratio'])
    circle_radius_multiplier: int = int(config['STAMPS']['hint_circle_radius_multiplier'])
    width_minimum: int = int(config['STAMPS']['image_width_min'])
    border_colour: str = config['STAMPS']['border_colour']
    circle_colour: str = config['STAMPS']['hint_circle_colour']
    directory_context: Path = Path(config['PATHS']['stamps_context'])
    directory_single: Path = Path(config['PATHS']['stamps_single'])

    for stamp in stamps:
        target_region = stamp.image.view.region

        # Get all stamps from the same patient as the current one, for the same body region
        patient_stamps: List[Stamp] = session.query(Stamp)\
            .join(Stamp.image, aliased=True)\
            .join(Image.view, aliased=True)\
            .filter_by(region=target_region).all()

        # But make sure we don't use a stamp as its own context!
        patient_stamps.remove(stamp)

        context_stamps: List[Stamp] = sample(patient_stamps, context_ratio)

        # Figure out what fraction of the size of the main stamp context stamps should be
        # At most  a 1:context_ratio fraction, but will be lower if needed to fit extras on
        context_relative_size: float = min(
            1 / len(context_stamps), 1 / context_ratio
        )

        # Open the existing stamp, and upscale the image if it's too small to show properly on Zooniverse,
        # as it doesn't scale
        if substitute:
            pil_stamp_single: PILImageClass = PILImage.open(
                Path(substitute)
            )
        else:
            pil_stamp_single: PILImageClass = PILImage.open(
                str(directory_single / stamp.filepath_single)
            )

        scale_factor: int = 1
        if pil_stamp_single.width < width_minimum:
            # We make sure the scaling is integer, as we don't want to introduce artefacts
            # into moles that are on the order of pixels across
            scale_factor = ceil(width_minimum / pil_stamp_single.width)
            pil_stamp_single = pil_stamp_single.resize(
                (pil_stamp_single.width * scale_factor, pil_stamp_single.height * scale_factor),
                PILImage.NEAREST
            )

        # Paste the (potentially upscaled) stamp into a new image,
        # adding a buffer at the bottom to leave space for context stamps
        pil_stamp: PILImageClass = PILImage.new(
            'RGB',
            (pil_stamp_single.width, int(pil_stamp_single.height*(1+context_relative_size)))
        )
        pil_stamp.paste(
            pil_stamp_single, (0, 0)
        )

        # Draw a bounding box around the image
        draw: Draw = Draw(pil_stamp)
        draw_frame_and_circle(
            draw=draw,
            position=(0, 0),
            size=(pil_stamp_single.width, pil_stamp_single.height),
            circle_radius=int(stamp.size * circle_radius_multiplier * scale_factor),
            line_width=max(pil_stamp_single.width // border_ratio, 1),
            border_colour=border_colour,
            circle_colour=circle_colour
        )

        # Now open up the sample of stamps selected for context, resize and add them
        for index, context_stamp in enumerate(context_stamps):
            if substitute:
                pil_stamp_context = PILImage.open(
                    Path(substitute)
                )
            else:
                pil_stamp_context = PILImage.open(
                        str(directory_single / context_stamp.filepath_single)
                )

            position_x: int = int(pil_stamp_single.width * context_relative_size) * index
            position_y: int = pil_stamp_single.height
            size_w: int = int(pil_stamp_single.width * context_relative_size)
            size_h: int = int(pil_stamp_single.height * context_relative_size)
            context_scale_factor: float = size_w / pil_stamp_context.width

            # Paste in the context stamp and draw a boundary box around it
            pil_stamp.paste(
                pil_stamp_context.resize(
                    (size_w, size_h)
                ),
                (position_x, position_y)
            )
            draw_frame_and_circle(
                draw=draw,
                position=(position_x, position_y),
                size=(size_w, size_h),
                circle_radius=int(context_stamp.size * circle_radius_multiplier * context_scale_factor),
                line_width=max(size_w // border_ratio, 1),
                border_colour=border_colour,
                circle_colour=circle_colour
            )

        # We decide where the context stamp image will be, create the directory if needed,
        # and then save, and update the stamp database entry with that info.
        path_stamp_context: Path = directory_context / stamp.filepath_single
        path_stamp_context.parent.mkdir(parents=True, exist_ok=True)
        pil_stamp.save(path_stamp_context)

        logger.debug(
            f"Generated context for {stamp}"
        )

        stamp.filepath = str(path_stamp_context.relative_to(directory_context))

    voidorchestra.db.commit_database(session)
